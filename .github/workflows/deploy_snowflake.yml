name: Snowflake Schema Change

on:
  push:
    branches:
      - main
      - master
  workflow_dispatch:

jobs:
  deploy-snowflake-changes:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install schemachange
        run: pip install schemachange

      - name: Determine Credentials
        id: credentials
        shell: bash
        run: |
          # If SNOWFLAKE_KEY secret exists and is not empty, use it.
          if [[ -n "${{ secrets.SNOWFLAKE_KEY }}" ]]; then
            echo "Using SNOWFLAKE_KEY"
            # We can pass the key content directly via env var since standard Snowflake connectors 
            # often require a path. However, schemachange might support env var directly or we write to file.
            # Best practice for CLI tools often involves writing the key to a temporary file.
            echo "${{ secrets.SNOWFLAKE_KEY }}" > snowflake_key.p8
            chmod 600 snowflake_key.p8
            echo "SNOWFLAKE_PRIVATE_KEY_PATH=$(pwd)/snowflake_key.p8" >> $GITHUB_ENV
            # Set a flag to know we are using key pair auth
            echo "USE_KEY_PAIR=true" >> $GITHUB_ENV
          else
            echo "Using SNOWFLAKE_PASSWORD"
            echo "SNOWFLAKE_PASSWORD=${{ secrets.SNOWFLAKE_PASSWORD }}" >> $GITHUB_ENV
            echo "USE_KEY_PAIR=false" >> $GITHUB_ENV
          fi

      - name: Create METADATA database if missing
        env:
          SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}
          # SNOWFLAKE_PASSWORD, SNOWFLAKE_PRIVATE_KEY_PATH, USE_KEY_PAIR are in GITHUB_ENV
        shell: python
        run: |
          import os
          import snowflake.connector
          from cryptography.hazmat.backends import default_backend
          from cryptography.hazmat.primitives import serialization

          account = os.environ.get('SNOWFLAKE_ACCOUNT')
          user = os.environ.get('SNOWFLAKE_USER')
          use_key_pair = os.environ.get('USE_KEY_PAIR')
          
          password = os.environ.get('SNOWFLAKE_PASSWORD')
          private_key_path = os.environ.get('SNOWFLAKE_PRIVATE_KEY_PATH')

          connect_args = {
              "account": account,
              "user": user,
              "warehouse": "COMPUTE_WH", # Default warehouse
              "database": "SNOWFLAKE", # Connect to system DB initially
              "schema": "PUBLIC"
          }

          if use_key_pair == 'true':
              with open(private_key_path, "rb") as key:
                  p_key= serialization.load_pem_private_key(
                      key.read(),
                      password=None,
                      backend=default_backend()
                  )
              
              pkb = p_key.private_bytes(
                  encoding=serialization.Encoding.DER,
                  format=serialization.PrivateFormat.PKCS8,
                  encryption_algorithm=serialization.NoEncryption())
              
              connect_args["private_key"] = pkb
          else:
              connect_args["password"] = password

          print("Connecting to Snowflake to verify METADATA database...")
          try:
              conn = snowflake.connector.connect(**connect_args)
              cs = conn.cursor()
              print("Creating database METADATA if not exists...")
              cs.execute("CREATE DATABASE IF NOT EXISTS METADATA")
              print("Database METADATA ensured.")
          except Exception as e:
              print(f"Error creating database: {e}")
              # We don't exit with error here to let schemachange try, 
              # but usually if this fails schemachange will also fail.
              # actually let's raise so we see the error clearly
              raise e
          finally:
              if 'conn' in locals():
                  conn.close()

      - name: Debug file structure
        run: ls -R

      - name: Run schemachange
        env:
          SNOWFLAKE_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
          SNOWFLAKE_USER: ${{ secrets.SNOWFLAKE_USER }}
          # The password env is set in the previous step if applicable
        run: |
          # Construct the command dynamic arguments
          CMD="schemachange deploy -f $GITHUB_WORKSPACE/scripts_sql -a $SNOWFLAKE_ACCOUNT -u $SNOWFLAKE_USER --create-change-history-table"
          
          # Add authentication arguments
          if [[ "$USE_KEY_PAIR" == "true" ]]; then
            # Using private key path
            CMD="$CMD --private-key-path $SNOWFLAKE_PRIVATE_KEY_PATH"
          else
            # Using password (it might need to be passed as env var SNOWFLAKE_PASSWORD purely, 
            # or usually schemachange automatically picks up SNOWFLAKE_PASSWORD env var if not passed as arg?
            # Looking at schemachange docs, strictly it uses env vars often. 
            # But let's verify if we need to be explicit or if env var is enough.
            # Usually env var SNOWFLAKE_PASSWORD is picked up by the connector.
            # We will rely on the env var we set: SNOWFLAKE_PASSWORD
            : # No-op, env var is set
          fi
          
          # Add other required params if user wants (warehouse, role, database).
          # Since user didn't specify them in prompt, we assume they might be in secrets or defaults.
          # For now, let's assume they might be passed or user relies on default user defaults.
          # However, schemachange usually requires database/warehouse/role/schema to manage the changelog.
          # We'll just run it. If it fails due to missing warehouse, user can add it.
          # Let's add basic print of what we are doing
          echo "Executing schemachange..."
          
          # run it
          $CMD
